lec 10 02/15 functional dependencies

Database Design
    Requirements Analysis
    Conceptual Database Design
    Logical Database Design
    Schema Refinements - lec 10-11
        - functional dependency
        - normalization
    Physical Database Design
    Application and Security Design

Outline
    Functional dependencies
    Armstrong's rules
    The closure algorithm
    Keys and superkeys

Motivation
    e.g.
    SSN     name    rating  hourly_wages    hours_worked
    ssn1    name1     8         10              40
    ssn2    name2     8         10              30
    ssn3    name3     5         7               30
    ssn4    name4     5         7               32
    ssn5    name5     8         10              40

    Functional Dependency (FD)
        - rating determines hourly_wages
        - if two tuples have the same rating, they must have the same hourly_wages
        - this leads to possible redundancy

    Problems:
      - Redundant storage
            Rating value 8 corresponding to hourly_wages 10 is repeated three times.
      - Update anomalies
            The hourly_wage in one tuple can be updated without changing other tuples.
      - Insertion anomalies
            Cannot insert a tuple unless we know the hourly_wage for the given rating.
      - Deletion anomalies
            If delete all tuples with a given rating value, lose the association
            between rating and hourly_wages.

    Solutions: Decomposition
        Seperate the original table into 2
        from:
            ssn, name, rating, hourly_wages, hours_worked
        to:
            ssn, name, rating, hours_worked
            rating, hourly_wages

Functional Dependency (FD)
    
    Definition
        Functional Dependencies (FDs) are a form of constraint that generalize the
        concept of keys
            if 2 tuples agree on the attributes
                A = A1, A2, ..., Am
            then they must agree on the attributes
                B = B1, B2, ..., Bm
            formally:
                A1, ..., Am -> B1, ..., Bm
            We then says that A "functionally determines" B.
        
        FDs help us detect redundancy in a schema and tell us how to normalize it.
            
    Identifying FDs
        An FD is domain knowledge:
            An inherent property of the application & data
            Not something we can infer from a set of tuples
        Given a table with a set of tuples
            We can confirm that a FD "seems" to be valid
            To infer that a FD is "definitely" invalid
            We can never prove that a FD is valid.

    Example 1
        In the table (ssn, name, rating, hourly_wages, hours_worked),
            rating -> hourly_wages
            ssn -> name, rating, hourly_wages, hours_worked
        

Armstrong's rules

    Armstrong's Axioms
        Reflexivity:
            For any subset X of {A1, ..., An}: A1, ..., An -> X.
            e.g. 
                A -> A
                A, B -> B
                A, B, C -> A, B, C

        Augmentation:
            For any attribute sets X, Y, Z: if X->Y then X,Z -> Y,Z.
            e.g.
                (A->A) -> (A,C->B,C)

        Transitivity:
            For any attribute sets X, Y, Z: if X->Y and Y->Z then X->Z.
            e.g.
                (A->B and B->C) -> (A->C)

    Applying Armstrong's Axioms
        Product(name, category, color, department, price)
            name            ->  color
            category        ->  department
            color, category ->  price
        Inference: 
            name, category -> price
            Augmentation: name, category -> color, category
            Transitivity: name, category -> color, category -> price


Closure Algorithm
    FD Closure
        If F is a set of FDs, the closure F+ is the set of all FDs logically
        implied by F.
        
        RMK: Armstrong's axioms are
                Sound: 
                    any FD generated by an axiom belongs in F+
                Complete: 
                    repeated application of the axioms will generate all FDs in F+
    
    Closure of attribute sets
        Attribute Closure
            If X is an attribute set, the closure X+ is in the set of all attributes
            such that X->B.

        In other words:
            X+ includes all attributes that are functionally determined 
            from X.
        
        Example
            Product(name, category, color, department, price)
                name            ->  color
                category        ->  department
                color, category ->  price

            Attribute Closure
                {name}+ = {name, color}
                {name, category}+ = {name, category, color, department, price}

        Calculate Attribute Closure
            psedo:
                Let X = {A1, ..., An}
                // add attributes implied by some subsets of X repeatedly
                while X is changing:
                    if (B1, ..., Bm -> C is an FD) && (B1, ..., Bm are all in X)
                        add C to X
                print(X)

            e.g.
                R(A, B, C, D, E, F)
                    A, B    ->  C
                    A, D    ->  E
                    B       ->  D
                    A, F    ->  B
                Compute the attribute closure:
                    {A, B}+ = {A, B, C, D, E}
                    {A, F}+ = {A, B, C, D, E, F}

    Attribute Closure to FD closure
        Does X->Y hold?
            We can check if Y is a subset of X+

        To compute the closure F+ of FDs
            for each subset of attributes X, compute X+
            for each subset of attributes Y in X+, output the FD X->Y


Keys and superkeys
    Superkeys
        A set of attributes A1, ..., An such that for any other attribute B in 
        the relation:
            A1, ..., An -> B        // B can be functionally determined by A1, ..., An

    Key (or candidate key)
        A minimal superkey          // a key is a superkey
        None of its subsets functionally determines all attributes of the relation

    RMK:
        If a relation has multiple keys, we specify one to be the primary_key

    Computing Keys and Superkeys
        Compute X+ for all sets of attributes X
        If X+ = all attributes, then X is a superkey
        If no subset of X is a superkey, then X is also a key.
    
        Example
            Product(name, category, color, department, price)
                name            ->  color
                category        ->  department
                color, category ->  price

            Superkeys
                {name, category},
                {name, category, price},
                {name, category, color},
                {name, category, price, color}

            Keys
                {name, category}
    Multiple keys
        It is possible to have many keys in a relation R.
        e.g.
            R(A, B, C) with FDs
                A, B -> C
                A, C -> B
        
